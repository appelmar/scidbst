% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/apply.R
\docType{methods}
\name{r.apply,scidbst,function-method}
\alias{r.apply}
\alias{r.apply,scidb,function-method}
\alias{r.apply,scidbst,function-method}
\title{Applys a custom R function on chunks of an array}
\usage{
\S4method{r.apply}{scidbst,`function`}(x, f, array, packages,
  parallel = FALSE, cores = 1, aggregates, output, logfile, dim, dim.spec,
  method = "rexec", ...)

\S4method{r.apply}{scidb,`function`}(x, f, array, packages, parallel = FALSE,
  cores = 1, aggregates = c(), output, logfile, ...)
}
\arguments{
\item{x}{scidbst array or scidb array}

\item{f}{r function of form \code{function(x) { ... }} expecting parameter x, which is a subset of the incoming data based on the aggregate statement}

\item{array}{string with the name of the output array}

\item{packages}{a vector of string of the packages required for the function f}

\item{parallel}{(optional) boolean whether or not the chunk is processed in parallel at an instance}

\item{cores}{(optional) if using parallel this specifies the number of cores to use at an instance}

\item{aggregates}{(optional) a vector of attribute names to group by}

\item{output}{a named list of output attributes and its scidb type (if using rexec method it will be 'double' regardless)}

\item{logfile}{(optional) the file path used to log during the processing if required}

\item{dim}{(optional) a named list with attribute name = output attribute name e.g. \code{list(dimy="y",dimx="x")}}

\item{dim.spec}{(optional) a named list with the dimension specification using the output dimension name as a identifier and a named numeric vector with min, max, overlap and chunk to specify the dimensionality}

\item{method}{The method to use, either "rexec" or "stream"; not utilized currently}
}
\value{
scidbst array or scidb array depending on the input
}
\description{
This function applies a custom r function on each individual scidbst array chunk using r_exec.
}
\details{
The script that is created during this function will handle the installation of required R-packages on
each of the instances. Then it combines the incoming attribute vectors to a data.frame object, which is passed
on to the '\code{\link[plyr]{ddply}}' function of the package 'plyr'. Depending on the stated aggregates parameter
the function 'f' is applied on that grouped sub data.frame object (parameter x of function f). Using the output
list the array will be projected on to the selected attributes. When specifying 'dim' and 'dim.spec' the stated
columns of the data.frame will be used as dimension in a perceeding redimension call.
}
\note{
The function that can be stated has the following description "function(x,...) {}". The x parameter is a
data.frame of the attributes stored in one chunk. In most cases you are advised to transform the array to have the
dimension values as attributes if you need those to perform calculations. The function will be passed on to the \link[plyr]{ddply}
function.

parameter option "stream" for 'method' currently not supported, use \link[scidbst]{stream} instead
}
\examples{
\dontrun{
 input.arr = scidbst("some_scidbst_array")
 input.arr = transform(input.arr, dimx="double(x)",dimy="double(y)", dimt="double(t)")
 f <- function(x) {
     if (is.null(x)) {
       return(c(nt=0,var=0,median=0,mean=0))
     }
     t = x$dimt
     n = x$val
     return(c(nt=length(t),var=var(n),median=median(n),mean=mean(n)))
   }
 rexec.arr = r.apply(x=input.arr,
     f=f,
     array="output_array",
     parallel=FALSE,
     cores=1,
     aggregates=c("dimy","dimx"),
     output=list(dimy="double",dimx="double",nt="double",var="double",median="double",mean="double"),
     dim=list(dimy="y",dimx="x"),
     dim.spec=list(y=c(min=0,max=99,chunk=20,overlap=0),x=c(min=0,max=99,chunk=20,overlap=0)),
     logfile="/tmp/logfile.log")
}
}

