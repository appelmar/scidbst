---
title: "Slope and Aspect Calculation using 'scidbst' and r_exec"
output: html_document
---

```{r connecting}
library(scidbst)
library(rgdal)
source("/home/lahn/GitHub/scidbst/vignettes/assets/credentials.R")
scidbconnect(host=host,port=port,user=user,password=password,protocol="https",auth_type = "digest")
```

# Pretest with a subset of the SRTM array

```{r}
srtm.ethiopia = scidbst("srtm_ethiopia")

srtm.sub = subarray(srtm.ethiopia,limits=extent(33.5,35,6.5,8))
srtm.sub = scidbsteval(srtm.sub,"temp_srtm_sub")
estimateFileSize(srtm.sub, unit="MB")

srtm.sub@proxy = scidb::repart(as(srtm.sub,"scidb"),upper=c(1801,1801),chunk=c(451,451),overlap=c(1,1))
srtm.sub = scidbsteval(srtm.sub, "srtm_sub_reparted")

scidbrm("temp_srtm_sub",force=TRUE)

# srtm.ethiopia.sub = scidbst("srtm_sub")
# regridded = regrid(srtm.ethiopia,c(10,10),"avg(band1)")

schema(as(srtm.sub,"scidb"))
#create a subset

#change the partioning
# reparted = scidb::repart(as(srtm.ethiopia,"scidb"),overlap=c(1,1))
# srtm.ethiopia@proxy = reparted
# srtm.ethiopia = scidbsteval(srtm.ethiopia,"srtm_eth_reparted")

srtm.sub

srtm.ethiopia.prep = transform(srtm.sub, dimy="double(y)",dimx="double(x)",band1 = "double(band1)")
srtm.ethiopia.prep = scidbsteval(srtm.ethiopia.prep,"srtm_sub_reparted_prep")

# srtm.ethiopia.prep = scidbst("srtm_sub_reparted_prep")
# scidbrm("srtm_sub_reparted_prep",force=T)
```

```{r}
slopeAspect = function(x) {
  data = x
  xdim = "dimx"
  ydim = "dimy"
  heightAttr = "band1"
  
  coordinates(data) <- c(xdim,ydim)
  gridded(data) <- TRUE
  data = as(data, "RasterStack")
  x_cellsize = 90
  y_cellsize = 90

  dx = focal(subset(x=data,subset=heightAttr,drop=TRUE), w=matrix(c(-1,-2,-1, 0, 0, 0, 1, 2, 1)/(8*x_cellsize),nr = 3, nc=3))
  dy = focal(subset(x=data,subset=heightAttr,drop=TRUE), w=matrix(c(-1,-2,-1, 0, 0, 0, 1, 2, 1)/(8*y_cellsize),nr = 3, nc=3,byrow = TRUE))
  slope = atan(sqrt(dx^2+dy^2)) *180/pi
  names(slope) = c("slope")
  aspect = atan2(dy,-1 * dx)* 180/pi
  names(aspect) = c("aspect")
  data = stack(list(data,slope,aspect))
  out = cbind(dimy=coordinates(data)[,"y"],dimx=coordinates(data)[,"x"],as.data.frame(data))
  out =na.omit(out)
  out = as.data.frame(out)

  
  return(out)
}
```


```{r}
#<band1:int16> [y=0:1801,451,1,x=0:1801,451,1]
system.time({
sa.array <- r.apply(x=srtm.ethiopia.prep,
                   f = slopeAspect,
                   array = "srtm_eth_slo_asp",
                   packages = c("raster","sp","rgdal"),
                   aggregates=c(),
                   output = list(dimy="double",dimx="double",band1="double",slope="double",aspect="double"),
                   dim = list(dimy="y",dimx = "x"),
                   dim.spec=list(y=list(min=0,max=1801,chunk=451,overlap=1),x=list(min=0,max=1801,chunk=451,overlap=1))
                   )
}) #~ 23s

brick = as(sa.array,"RasterBrick")
spplot(subset(brick,"band1"),main="Heights in m")
spplot(subset(brick,"slope"),main="Slope in degree")
spplot(subset(brick,"aspect"),main="Aspect in degree")
```


# Testing slope and aspect calculation on the SRTM dataset

After the intial test, we will now apply the function to the whole African SRTM dataset.

Prepare the original SRTM data set to incorporate overlap.

```{r}
srtm = scidbst("SRTM_AFRICA")
# estimateFileSize(srtm) ~ 72GB

schema(as(srtm,"scidb"))
#<band1:int16> [y=-6001:84001,2048,0,x=-1:90002,2048,0]

srtm@proxy = scidb::repart(as(srtm,"scidb"),upper=c(84001,90002),chunk=c(2048,2048),overlap=c(1,1))
srtm.prep = transform(srtm,dimy="double(y)",dimx="double(x)",band1="double(band1)")

srtm.prep = scidbsteval(srtm.prep,"srtm_africa_prep")


# srtm.prep = scidb("srtm_africa_prep")
# srtm.prep = copySRS(srtm.prep,srtm)

# scidbst("srtm_africa_prep")
```

We need to state the x and y cellsizes of the image in order to calculate slope and aspect in meters, since the height is also stated in meters. The source array has coordinates in latitude-longitude and therefore the meter sizes of the cells would vary through out the image. To make the example easier to understand we will neglect the inaccuracies and use an approximated meter value for the resolutions. We justify this by the assumption that the cellsizes of neighboring cells will change similarly throughout the image, so that the differences are quite small. So we state the cellsizes with 90m in this calculation.

The function 'slopeAspect' will work in the following way:
1. create a RasterStack object of the chunk data by creating a data.frame into a SpatialPixelDataFrame and coercing this to a RasterStack
2. use focal operators with 9x9 matrices as a moving window calculating the derivations in x and y
3. calculate the slope and aspect values in degrees for each cell using the derivations and add it to the RasterStack
4. create the output data.frame from the RasterStack and return it 

Note: Due to the lack of values in the outer boundary there will be a 1 pixel border around the array. With na.omit we will remove it from being stored as a NA value.

```{r}
slopeAspect = function(x) {
  data = x
  xdim = "dimx"
  ydim = "dimy"
  heightAttr = "band1"
  
  coordinates(data) <- c(xdim,ydim)
  gridded(data) <- TRUE
  data = as(data, "RasterStack")
  x_cellsize = 90
  y_cellsize = 90

  dx = focal(subset(x=data,subset=heightAttr,drop=TRUE), w=matrix(c(-1,-2,-1, 0, 0, 0, 1, 2, 1)/(8*x_cellsize),nr = 3, nc=3))
  dy = focal(subset(x=data,subset=heightAttr,drop=TRUE), w=matrix(c(-1,-2,-1, 0, 0, 0, 1, 2, 1)/(8*y_cellsize),nr = 3, nc=3,byrow = TRUE))
  slope = atan(sqrt(dx^2+dy^2)) *180/pi
  names(slope) = c("slope")
  aspect = atan2(dy,-1 * dx)* 180/pi
  names(aspect) = c("aspect")
  data = stack(list(data,slope,aspect))
  out = cbind(dimy=coordinates(data)[,"y"],dimx=coordinates(data)[,"x"],as.data.frame(data))
  out =na.omit(out)
  out = as.data.frame(out)

  
  return(out)
}
```

The *aggregate* parameter will be empty. In this case the whole chunk is passed to ddply and the function will be applied. In this example we will be performing the redimensioning after the calculation was performed. This means that the dimension names and schema need to be stated. Since there is almost no change in the array structure, except the 1 pixel border, we will reuse the array schema of the source SRTM array.
By renaming the dimension in the same manner as the source array, the spatial reference will be copied as well.

```{r}
system.time({
sa.array <- r.apply(x=srtm.prep,
                   f = slopeAspect,
                   array = "srtm_africa_slope_asp",
                   packages = c("raster","sp","rgdal"),
                   aggregates=c(),
                   output = list(dimy="double",dimx="double",band1="double",slope="double",aspect="double"),
                   dim = list(dimy="y",dimx = "x"),
                   dim.spec=list(y=list(min=-6001,max=84001,chunk=2048,overlap=1),x=list(min=-1,max=90002,chunk=2048,overlap=1))
                   )
})
```

